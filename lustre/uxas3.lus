-- uxas.lus

-- Driver for compositional reasoning about OpenUxAS.

include "common/types.lus"
include "common/pltl.lus"

include "services/automation-request-validator.lus"
include "services/waypoint-manager.lus"


--
-- The OpenUxAS Framework
--
node uxas(
    -- The message currently received by the system
    in_msg : message;

    -- The ID to be used for ID generation
    in_id : id_type;
) returns (
    -- The message currently sent by the system
    out_msg : message;

    -- The ID to be used for future ID generation
    out_id : id_type;
);
var
    -- Variables for Automation Request Validator output
    arv_msg : message;
    arv_id  : id_type;

    -- Variables for 
    wm_msg : message;
    wm_id  : id_type;

const
    -- These constants represent skolemized universally quantified variables 
    -- that we use to link details of a message appearing the past with details
    -- of our output message.
    -- automation_response_msg        : message;
    unique_automation_response_msg : message;
 
let
    -- Choice of the free messages must satisfy our identity predicate, in 
    -- particular in relation to inputs. This doesn't mean that the free
    -- messages *must* be an input *unless* the ID is so constrained.
    assert (ids_imply_equality(in_msg, automation_response_msg));
    assert (ids_imply_equality(in_msg, unique_automation_response_msg));


    -- ===================================================================== --
    -- Environment Modeling

    -- This assertion describes how the input is allowed to evolve. This is
    -- meant to be a rough model of a message bus.
    assert (
        -- no message
        (in_msg = no_message and 
         in_id  = (0 -> pre(in_id)))
         
        or

        -- the previously sent message (loop closure)
        (in_msg = (no_message -> pre(out_msg)) and 
         in_msg <> no_message and
         in_id  = in_msg.id)
        
        or

        -- a Unique Automation Request with a valid id
        (in_msg.kind = unique_automation_response and 
         in_msg.id = in_id and
         in_id > (0 -> pre(in_id)))
    );

    -- Constrain the model to sending one message per step. If we imagine that
    -- the steps are events, this really just means that the system processes
    -- one event at a time. This seems like a reasonable abstraction for
    -- ZeroMQ, which will only allow one message to be retrieved per step. So
    -- this constraint effectively saves us from having to model a message bus
    -- that allows arbitrarily many messages to be sent and then queued up for
    -- retrieval one at a time.
    --
    -- A more interesting approach might be to pass all messages to a node that
    -- represents the bus and have the node pick a random order in which to
    -- output the messages. The constraint could be that no new messages could
    -- be sent until the bus was "empty". This would allow message orders to be
    -- arbitrary.
    assert
        not (
            arv_msg <> no_message and
            wm_msg  <> no_message
        );


    -- ===================================================================== --
    -- Service Execution

    arv_msg, arv_id = automation_request_validator(in_msg, in_id);
    wm_msg,  wm_id  = waypoint_manager(in_msg, in_id);


    -- ===================================================================== --
    -- Output Selection

    -- Select the message for output; we know there will be only one, so order
    -- doesn't matter. Conceptually, this is like a Simulink merge block.
    out_msg, out_id   = if arv_msg <> no_message then
                            (arv_msg, arv_id)
                        else if wm_msg <> no_message then
                            (wm_msg, wm_id)
                        else
                            (no_message, in_id);


    -- ===================================================================== --
    -- Environment Consistency Checks

    -- These aren't required for proof, but help with troubleshooting
    -- failing properties (by making cleaner inductive counterexamples).

    check "E1: input IDs are non-decreasing."
        in_id >= (0 -> pre(in_id));

    check "E2: input IDs are nonnegative."
        in_id >= -1;

    check "E3: in message IDs are increasing."
        in_msg <> no_message => (
            in_msg.id > (-1 -> pre(in_msg.id))
        );

    check "E4: in message IDs are nonnegative."
        in_msg <> no_message => (
            in_msg.id >= 0
        );

    check "E5: no_message has ID -1."
        in_msg = no_message => (
            in_msg.id = -1
        );


    -- ===================================================================== --
    -- Properties of Interest

    check "P1. All services correctly handle output ID and message ID."
        if out_msg <> no_message then
            out_msg.id = out_id and
            out_id     = in_id + 1
        else
            out_id = in_id;


    -- This property is gratuitous
    check "P2. Mission Command messages reference prior Automation Response
           messages."
        (
            out_msg.kind = mission_command and
            out_msg.ref  = automation_response_msg.id
        ) => (
            O(in_msg = automation_response_msg)
        );


    -- This property is gratuitous
    check "P3. Automation Response messages reference prior Unique Automation
           Response messages."
        (
            out_msg.kind = automation_response and
            out_msg.ref  = unique_automation_response_msg.id
        ) => (
            O(in_msg = unique_automation_response_msg)
        );


    -- ===================================================================== --
    -- Compositional Properties of Interest

    check "C1. Mission Command messages reference, transitively, prior Unique
           Automation Response messages."
        (
            out_msg.kind = mission_command and
            out_msg.ref  = automation_response_msg.id and

            automation_response_msg.id = unique_automation_response_msg.id
        ) => (
            O(in_msg = automation_response_msg) and
            O(in_msg = unique_automation_response_msg)
        );


    -- This is the first step towards a composition proof of waypoint on first
    -- statement of route. It fails because we cannot see the lemma about
    -- pre_route from the Waypoint Manager (P5) at this scope. This needs
    -- thought.
    -- check "route 1"
    --     (
    --         out_msg.kind  = mission_command and
    --         out_msg.ref   = automation_response_msg.id
    --     ) => (
    --         contains(automation_response_msg.route, out_msg.waypoint)
    --     );    
        
        
    -- check "route final"
    --     (
    --         out_msg.kind  = mission_command and
    --         out_msg.ref   = automation_response_msg.id and

    --         automation_response_msg.id = unique_automation_response_msg.id
    --     ) => (
    --         contains(unique_automation_response_msg.route, out_msg.waypoint)
    --     );    
tel;
