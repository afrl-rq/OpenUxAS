-- uxas.lus

-- Driver for compositional reasoning about OpenUxAS.

include "common/types.lus"
include "common/pltl.lus"

include "services/automation-request-validator.lus"
include "services/waypoint-manager.lus"


--
-- The OpenUxAS Framework
--
node uxas(
    -- The message currently received by the system
    in_msg : message;

    -- The ID to be used for ID generation
    in_id : id_type;
) returns (
    -- The message currently sent by the system
    out_msg : message;

    -- The ID to be used for future ID generation
    out_id : id_type;
);
var
    -- Variables for Automation Request Validator output
    arv_msg : message;
    arv_id  : id_type;

    -- Variables for 
    wm_msg : message;
    wm_id  : id_type;

const
    -- These constants represent skolemized universally quantified variables 
    -- that we use to link details of a message appearing the past with details
    -- of our output message.
    automation_response_id    : id_type;
    automation_response_route : route_type;

    unique_automation_response_id    : id_type;
    unique_automation_response_route : route_type;
 
let
    -- ===================================================================== --
    -- Environment Modeling

    -- This assertion describes how the input is allowed to evolve. This is
    -- meant to be a rough model of a message bus.
    assert (
        -- no message
        (in_msg = no_message and 
         in_id  = (0 -> pre(in_id)))
         
        or

        -- the previously sent message (loop closure)
        (in_msg = (no_message -> pre(in_msg)) and 
         in_msg <> no_message and
         in_id  = in_msg.id)
        
        or

        -- a Unique Automation Request with a valid id
        (in_msg.kind = unique_automation_response and 
         in_msg.id = in_id and
         in_id > (0 -> pre(in_id)))
    );

    -- Constrain the model to sending one message per step. If we imagine that
    -- the steps are events, this really just means that the system processes
    -- one event at a time. This seems like a reasonable abstraction for
    -- ZeroMQ, which will only allow one message to be retrieved per step. So
    -- this constraint effectively saves us from having to model a message bus
    -- that allows arbitrarily many messages to be sent and then queued up for
    -- retrieval one at a time.
    assert
        not (
            arv_msg <> no_message and
            wm_msg  <> no_message
        );


    -- ===================================================================== --
    -- Service Execution

    arv_msg, arv_id = automation_request_validator(in_msg, in_id);
    wm_msg,  wm_id  = waypoint_manager(in_msg, in_id);


    -- ===================================================================== --
    -- Output Selection

    -- Select the message for output; we know there will be only one, so order
    -- doesn't matter. Conceptually, this is like a Simulink merge block.
    out_msg, out_id   = if arv_msg <> no_message then
                            (arv_msg, arv_id)
                        else if wm_msg <> no_message then
                            (wm_msg, wm_id)
                        else
                            (no_message, in_id);


    -- check "Valid Mission Command"
    --     (
    --         out_msg.kind = mission_command and
    --         out_msg.ref  = automation_response_id and
    --         contains(unique_automation_response_route, out_msg.waypoint) and

    --         -- follow the reference chain to the expected source message
    --         O(in_msg.id  = automation_response_id and
    --           in_msg.ref = unique_automation_response_id)
    --     ) => (
    --         -- the expected source message exists and has the expected data
    --         O(in_msg.kind  = unique_automation_response and
    --           in_msg.id    = unique_automation_response_id and
    --           in_msg.route = unique_automation_response_route)
    --     );


    
    -- ===================================================================== --
    -- Lemmas
    --
    -- These properties are not necessarily of interest in and of themselves,
    -- but they are found to be necessary to prove properties of interest.

    check "Lemma 1: cannot receive two Automation Response messages in a row."
        (
            in_msg.kind = automation_response
        ) => (
            pre(in_msg.kind) <> automation_response
        );


    -- ===================================================================== --
    -- Environment Consistency Checks

    check "Environment: input IDs are non-decreasing."
        in_id >= (0 -> pre(in_id));


    -- ===================================================================== --
    -- Properties of Interest

    check "All services correctly handle output ID and message ID."
        if out_msg <> no_message then
            out_msg.id = out_id and
            out_id     = in_id + 1
        else
            out_id = in_id;


    check "Mission Command messages reference prior Automation Response
           messages."
        (
            out_msg.kind = mission_command and
            out_msg.ref  = automation_response_id
        ) => (
            O(in_msg.kind = automation_response and
              in_msg.id   = automation_response_id)

            and

            out_msg.id > automation_response_id
        );


    check "Automation Response messages reference prior Unique Automation
           Response messages."
        (
            out_msg.kind = automation_response and
            out_msg.ref  = unique_automation_response_id
        ) => (
            O(in_msg.kind = unique_automation_response and
              in_msg.id   = unique_automation_response_id)

            and

            out_msg.id > unique_automation_response_id
        );


    -- ===================================================================== --
    -- Compositional Properties of Interest

    -- Note: requres Lemma 1.
    check "Mission Command messages reference, transitively, prior Unique
           Automation Response messages."
        (
            out_msg.kind = mission_command and
            out_msg.ref  = automation_response_id and

            O(in_msg.kind = automation_response and
              in_msg.id   = automation_response_id and
              in_msg.ref  = unique_automation_response_id)

            and

            out_msg.id > automation_response_id and
            automation_response_id > unique_automation_response_id
        ) => (
            O(in_msg.kind = unique_automation_response and
              in_msg.id   = unique_automation_response_id)
        );
tel;
