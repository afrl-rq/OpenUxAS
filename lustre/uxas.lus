-- uxas.lus

-- Driver for compositional reasoning about OpenUxAS.

include "common/types.lus"
include "common/pltl.lus"
include "common/bus.lus"

include "services/automation-request-validator.lus"
include "services/waypoint-manager.lus"


--
-- The OpenUxAS Framework
--
-- Note: output r is required for Lustre syntax but is not used.
node uxas() returns (r : bool);
var
    -- data exchanged over the bus.
    in_msg, out_msg : message;
    in_id : id_type;

    -- Variables for Automation Request Validator output
    arv_msg : message;

    -- Variables for Waypoint Manager output
    wm_msg : message;
const
    -- used to prove properties about messages in this model
    free_msg1, free_msg2 : message;
let
    -- ===================================================================== --
    -- Environment Modeling

    in_msg, in_id = bus(no_message -> pre(out_msg));


    -- Constrain the model to sending one message per step.
    assert
        not (
            arv_msg <> no_message and
            wm_msg  <> no_message
        );


    -- ===================================================================== --
    -- Service Execution

    arv_msg = automation_request_validator(in_msg, in_id);
    wm_msg  = waypoint_manager(in_msg, in_id);


    -- ===================================================================== --
    -- Output Selection

    -- Select the message for output; we know there will be only one, so order
    -- doesn't matter. Conceptually, this is like a Simulink merge block.
    out_msg   = if arv_msg <> no_message then
                    arv_msg
                else if wm_msg <> no_message then
                    wm_msg
                else
                    no_message;


    -- ===================================================================== --
    -- Initial Conditions of Interest

    check "Bus IC.\n  "
    (
        O(in_msg = no_message or in_msg.kind = unique_automation_response)
    );

    check "ARV IC.\n  "
    (
        O(arv_msg = no_message)
    );

    check "WM IC.\n  "
    (
        O(wm_msg = no_message)
    );

    check "Output IC.\n  "
    (
        O(out_msg = no_message)
    );


    -- ===================================================================== --
    -- Environment Consistency Checks

    check "E1:
      input IDs are non-decreasing.\n  "
    (
        in_id >= (0 -> pre(in_id))
    );

    check "E2:
      input IDs are nonnegative.\n  "
    (
        in_id >= -1
    );

    check "E3:
      in message IDs are increasing.\n  "
    (
        in_msg <> no_message
    ) => (
        in_msg.id > (-1 -> pre(in_msg.id))
    );

    check "E4:
      in message IDs are nonnegative.\n  "
    (
        in_msg <> no_message
    ) => (
        in_msg.id >= 0
    );

    check "E5:
      no_message has ID -1.\n  "
    (
        in_msg = no_message
    ) => (
        in_msg.id = -1
    );

    check "E6:
      equal IDs imply equal messages for input messages\n  "
    (
        O(in_msg = free_msg1) and
        O(in_msg = free_msg2)
    ) => (
        ids_imply_equality(free_msg1, free_msg2)
    );

    check "E7:
      equal IDs imply equal messages for output messages\n  "
    (
        O(out_msg = free_msg1) and
        O(out_msg = free_msg2)
    ) => (
        ids_imply_equality(free_msg1, free_msg2)
    );

    check "E8:
      equal IDs imply equal messages for input and output messages\n  "
    (
        O(in_msg  = free_msg1) and
        O(out_msg = free_msg2)
    ) => (
        ids_imply_equality(free_msg1, free_msg2)
    );

    check "E9.
      Input mission command messages were always previously output.\n  "
    (
        in_msg.kind = mission_command and
        in_msg      = free_msg1
    ) => (
        O(out_msg = free_msg1)
    );

    check "E10.
      Input automation response messages were always previously output.\n  "
    (
        in_msg.kind = automation_response and
        in_msg      = free_msg1
    ) => (
        O(out_msg = free_msg1)
    );


    -- ===================================================================== --
    -- Properties of Interest

    check "P1.
      All services correctly handle output ID and message ID.\n  "
    (
        out_msg <> no_message
    ) => (
        out_msg.id = in_id + 1
    );

    check "P2.
      Reestablish Waypoint Manager R1.\n  "
    (
        out_msg.kind = mission_command and
        out_msg      = wm_future_out_msg
    ) => (
        O(in_msg.kind = automation_response and
          in_msg.id   = wm_future_out_msg.ref and
          contains(in_msg.route, wm_future_out_msg.waypoint))
    );

    check "P3.
      Reestablish Automation Request Validator R1.\n  "
    (
        out_msg.kind = automation_response and
        out_msg      = arv_future_out_msg
    ) => (
        O(in_msg.kind  = unique_automation_response and
          in_msg.id    = arv_future_out_msg.ref and
          in_msg.route = arv_future_out_msg.route)
    );


    -- ===================================================================== --
    -- Compositional Properties of Interest

    check "C1.
      Mission Command messages reference, transitively, prior Unique Automation
      Response messages.\n  "
    (
        out_msg.kind = mission_command and
        out_msg      = wm_future_out_msg and

        -- assume that the free constant wm_future_out_msg references the id
        -- of the free constant arv_future_out_msg. This is necessary for the
        -- transitive nature of the property.
        arv_future_out_msg.id = wm_future_out_msg.ref and

        -- assume that the free constant arv_future_out_msg is equal to a prior
        -- output. This is like saying `out_msg = wm_future_out_msg` above, but
        -- the equality isn't tied to the current time step. Again, necessary
        -- for the transitive nature of the property.
        O(out_msg = arv_future_out_msg)
    ) => (
        O(in_msg.kind = unique_automation_response and
          in_msg.id   = arv_future_out_msg.ref)
    );

    check "C2.
      Mission Command message waypoints are contained, transitively, on prior
      received Unique Automation Response messages.\n  "
    (
        out_msg.kind = mission_command and
        out_msg      = wm_future_out_msg and

        -- assume that the free constant wm_future_out_msg references the id
        -- of the free constant arv_future_out_msg. This is necessary for the
        -- transitive nature of the property.
        arv_future_out_msg.id = wm_future_out_msg.ref and

        -- assume that the free constant arv_future_out_msg is equal to a prior
        -- output. This is like saying `out_msg = wm_future_out_msg` above, but
        -- the equality isn't tied to the current time step. Again, necessary
        -- for the transitive nature of the property.
        O(out_msg = arv_future_out_msg)
    ) => (
        O(in_msg.kind = unique_automation_response and
          in_msg.id   = arv_future_out_msg.ref and
          contains(in_msg.route, wm_future_out_msg.waypoint))
    );


    -- ===================================================================== --
    -- Environment witnesses
    --
    -- These build confidence that the model has behaviors we expect.

    check "W1. Witness no_message from the bus."
    not (
        in_msg = no_message
    );

    check "W2. Witness unique_automation_response from the bus."
    not (
        in_msg.kind = unique_automation_response
    );

    check "W3. Witness automation_response from the bus."
    not (
        in_msg.kind = automation_response
    );

    check "W4. Witness mission_command from the bus."
    not (
        in_msg.kind = mission_command
    );

    check "W5. Witness arv_msg <> no_message."
    not (
        arv_msg <> no_message
    );

    check "W6. Witness arv_msg = no_message."
    not (
        arv_msg = no_message
    );

    check "W7. Witness wm_msg"
    not (
        wm_msg <> no_message
    );

    check "W8. Witness wm_msg = no_message."
    not (
        wm_msg = no_message
    );


    -- ===================================================================== --
    -- Antecedent Witnesses
    --
    -- These are grouped, rather than placed with their properties, so that
    -- they can easily be enabled / disabled: they tend to pollute the output
    -- when expected-true properties are falsified.

    check "E3.A. Witness antecedent of E3."
    not (
        in_msg <> no_message
    );

    check "E4.A. Witness antecedent of E4."
    not (
        in_msg <> no_message
    );

    check "E5.A. Witness antecedent of E5."
    not (
        in_msg = no_message
    );

    check "E6.A. Witness antecedent of E6."
    not (
        O(in_msg = free_msg1) and
        O(in_msg = free_msg2)
    );

    check "E7.A. Witness antecedent of E7."
    not (
        O(out_msg = free_msg1) and
        O(out_msg = free_msg2)
    );

    check "E8.A. Witness antecedent of E8."
    not (
        O(in_msg  = free_msg1) and
        O(out_msg = free_msg2)
    );

    check "E9.A. Witness antecedent of E9."
    not (
        in_msg.kind = mission_command and
        in_msg      = free_msg1
    );

    check "E10.A. Witness antecedent of E10."
    not (
        in_msg.kind = automation_response and
        in_msg      = free_msg1
    );


    check "P1.A. Witness antecedent of P1."
    not (
        out_msg <> no_message
    );

    check "P2.A. Witness antecedent of P2."
    not (
        out_msg.kind = mission_command and
        out_msg      = wm_future_out_msg
    );

    check "P3.A. Witness antecedent of P3."
    not (
        out_msg.kind = automation_response and
        out_msg      = arv_future_out_msg
    );

    check "C1.A. Witness antecedent of C1."
    not (
        out_msg.kind = mission_command and
        out_msg      = wm_future_out_msg and
        arv_future_out_msg.id = wm_future_out_msg.ref and
        O(out_msg = arv_future_out_msg)
    );
tel;
