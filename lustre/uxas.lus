-- uxas.lus

-- Driver for compositional reasoning about OpenUxAS.

include "common/types.lus"
include "common/pltl.lus"
include "common/bus.lus"

include "services/automation-request-validator.lus"
include "services/waypoint-manager.lus"


--
-- The OpenUxAS Framework
--
-- Note: output r is required for Lustre syntax but is not used.
node uxas() returns (r : bool);
var
    -- data exchanged over the bus.
    in_msg, out_msg : message;
    in_id : id_type;
    
    -- Variables for Automation Request Validator output
    arv_msg : message;

    -- Variables for Waypoint Manager output
    wm_msg : message;

const
    -- These constants represent skolemized universally quantified variables 
    -- that we use to link details of a message appearing the past with details
    -- of our output messages in properties.
    automation_response_msg        : message;
    unique_automation_response_msg : message;
 
let
    -- Choice of the free messages must satisfy our identity predicate, in 
    -- particular in relation to inputs. This doesn't mean that the free
    -- messages *must* be an input *unless* the ID is so constrained.
    assert (ids_imply_equality(in_msg, automation_response_msg));
    assert (ids_imply_equality(in_msg, unique_automation_response_msg));


    -- ===================================================================== --
    -- Environment Modeling

    in_msg, in_id = bus(no_message -> pre(out_msg));


    -- Constrain the model to sending one message per step. 
    assert
        not (
            arv_msg <> no_message and
            wm_msg  <> no_message
        );


    -- ===================================================================== --
    -- Service Execution

    arv_msg = automation_request_validator(in_msg, in_id);
    wm_msg  = waypoint_manager(in_msg, in_id);


    -- ===================================================================== --
    -- Output Selection

    -- Select the message for output; we know there will be only one, so order
    -- doesn't matter. Conceptually, this is like a Simulink merge block.
    out_msg   = if arv_msg <> no_message then
                            arv_msg
                        else if wm_msg <> no_message then
                            wm_msg
                        else
                            no_message;


    -- ===================================================================== --
    -- Environment Consistency Checks

    -- These aren't required for proof, but help with troubleshooting
    -- failing properties (by making cleaner inductive counterexamples).

    check "E1: input IDs are non-decreasing."
        in_id >= (0 -> pre(in_id));

    check "E2: input IDs are nonnegative."
        in_id >= -1;

    check "E3: in message IDs are increasing."
        in_msg <> no_message => (
            in_msg.id > (-1 -> pre(in_msg.id))
        );

    check "E4: in message IDs are nonnegative."
        in_msg <> no_message => (
            in_msg.id >= 0
        );

    check "E5: no_message has ID -1."
        in_msg = no_message => (
            in_msg.id = -1
        );


    -- ===================================================================== --
    -- Properties of Interest

    check "P1. All services correctly handle output ID and message ID."
        out_msg <> no_message => (
            out_msg.id = in_id + 1
        );


    -- This property is gratuitous
    check "P2. Mission Command messages reference prior Automation Response
           messages."
        (
            out_msg.kind = mission_command and
            out_msg.ref  = automation_response_msg.id
        ) => (
            O(in_msg = automation_response_msg)
        );


    -- This property is gratuitous
    check "P3. Automation Response messages reference prior Unique Automation
           Response messages."
        (
            out_msg.kind = automation_response and
            out_msg.ref  = unique_automation_response_msg.id
        ) => (
            O(in_msg = unique_automation_response_msg)
        );


    -- ===================================================================== --
    -- Compositional Properties of Interest

    check "C1. Mission Command messages reference, transitively, prior Unique
           Automation Response messages."
        (
            out_msg.kind = mission_command and
            out_msg.ref  = automation_response_msg.id and

            automation_response_msg.id = unique_automation_response_msg.id
        ) => (
            O(in_msg = automation_response_msg) and
            O(in_msg = unique_automation_response_msg)
        );


    -- This is the first step towards a composition proof of waypoint on first
    -- statement of route. It fails because we cannot see the lemma about
    -- pre_route from the Waypoint Manager (P5) at this scope. This needs
    -- thought.
    -- check "route 1"
    --     (
    --         out_msg.kind  = mission_command and
    --         out_msg.ref   = automation_response_msg.id
    --     ) => (
    --         contains(automation_response_msg.route, out_msg.waypoint)
    --     );    
        
        
    -- check "route final"
    --     (
    --         out_msg.kind  = mission_command and
    --         out_msg.ref   = automation_response_msg.id and

    --         automation_response_msg.id = unique_automation_response_msg.id
    --     ) => (
    --         contains(unique_automation_response_msg.route, out_msg.waypoint)
    --     );    
tel;
