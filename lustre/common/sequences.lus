-- sequences.lus
--
-- A partial theory of sequences realized in kind2's lustre. Consistency
-- properties are proved for the theory.
--
-- Functions prefixed with `_` should be considered private to the theory and
-- should not be used by clients.
--
-- The theory provides:
--


-- ------------------------------------------------------------------------- --
-- Element Type

-- Represent an element by an integer. This should be viewed as a reference to
-- the actual element.
type element_type  = int;


-- Declare -1 to be an invalid element.
const no_element : element_type = -1;


-- Generate a freely chosen element that is not no_element.
function _free_valid_element() returns (element : element_type);
(*@contract
    guarantee "valid element" element <> no_element;
*)
const 
    free_element : element_type;
let
    element = free_element; --_free_element();
    assert (element <> no_element);
tel;


-- ------------------------------------------------------------------------- --
-- Index Type

-- Represent an index. Valid indices are >= 0.
type index_type    = int;


-- Declare -1 to be an invalid index.
const no_index : index_type = -1;


-- Generate a freely chosen index that is >= 0.
function _free_valid_index() returns (index : index_type);
(*@contract
    guarantee "valid index " index >= 0;
*)
const
    free_index : index_type;
let
    index = free_index;
    assert (index >= 0);
tel;


-- ------------------------------------------------------------------------- --
-- Sequence Type

-- Represent a sequence by its first and last indices.
type sequence_type = struct {
    first_index : index_type;
    last_index  : index_type;
};


-- Define an empty sequence to have no_index for both first and last indices.
const empty_sequence : sequence_type = sequence_type {
    first_index = no_index;
    last_index  = no_index;
};


-- A predicate that defines a (valid) nonempty sequence to have positive
-- indices such that first <= last.
function nonempty_sequence(sequence : sequence_type) returns (r : bool);
let
    r = 0 <= sequence.first_index and
             sequence.first_index <= sequence.last_index;
tel;


-- A predicate that defines a valid sequence to be empty or to have valid
-- indices.
function valid_sequence(sequence : sequence_type) returns (r : bool);
let
    r = sequence = empty_sequence or
        nonempty_sequence(sequence);
tel;


-- A predicate that defines an index to be valid for a given sequence if it is
-- in [first_index, last_index].
function valid_index(sequence : sequence_type; index : index_type) returns (r : bool);
let
    r = sequence.first_index <= index and index <= sequence.last_index;
tel;


-- ------------------------------------------------------------------------- --
-- get operation

-- Generate a freely chosen element given a sequence and an index.
function _access(sequence : sequence_type; index : index_type) returns (r : element_type);
let
tel;


-- Get the element from the sequence at the given index. If the index is valid
-- for the sequence, we are guaranteed to get an element that we can then
-- successfully find using any_index_of. (This is proven, below.)
function get(sequence : sequence_type; index : index_type) returns (element : element_type);
let
    element = if nonempty_sequence(sequence) and
                 valid_index(sequence, index)
              then
                  _access(sequence, index)
              else
                  no_element;

    assert (
        if nonempty_sequence(sequence) and valid_index(sequence, index) then
            element <> no_element and 
            _constrained_find_any(sequence, element) = index
        else
            element = no_element
    );
tel;


-- ------------------------------------------------------------------------- --
-- any_index_of operation

-- Generate a freely chosen index given a sequence and an element.
function _find_any(sequence : sequence_type; element : element_type) returns (index : index_type);
let
tel;


-- Generate a freely chosen index given a sequence and an element such that if
-- the generated index is not no_index, the index will be valid for the given
-- sequence.
function _constrained_find_any(sequence : sequence_type; element : element_type) returns (index : index_type);
let
    index = _find_any(sequence, element);
    assert (index <> no_index => (nonempty_sequence(sequence) and valid_index(sequence, index)));
tel;


-- Return any index of the given element in the given sequence. Since an
-- element may appear multiple times in the sequence, this represents a free
-- choice in which index is returned.
--
-- If the index is not no index, then get(sequence, index) returns the element
-- sought. (This is proven, below.)
function any_index_of(sequence : sequence_type; element : element_type) returns (index : index_type);
let
    index = if element <> no_element then
                _constrained_find_any(sequence, element)
            else
                no_index;

    assert (index <> no_index => (_access(sequence, index) = element));
tel;


-- ------------------------------------------------------------------------- --
-- first_index_of operation

-- Generate a freely chosen index given a sequence and an element.
function _find_first(sequence : sequence_type; element : element_type) returns (index : index_type);
let
tel;


-- Return the first index of the given element in the given sequence.
--
-- If the index is not no index, then get(sequence, index) returns the element
-- sought. (This is proven, below.)
--
-- If the index is not no index, there is no other occurrence of the element
-- at a smaller, valid index in the sequence. (This is proven, below.)
function first_index_of(sequence : sequence_type; element : element_type) returns (index : index_type);
let
    index = if element <> no_element then
            _find_first(sequence, element)
        else
            no_index;

    assert (index <> no_index => (nonempty_sequence(sequence) and
                                  valid_index(sequence, index) and 
                                  (_access(sequence, index) = element)));
tel;


-- ------------------------------------------------------------------------- --
-- last_index_of operation

-- Generate a freely chosen index given a sequence and an element.
function _find_last(sequence : sequence_type; element : element_type) returns (index : index_type);
let
tel;


-- Return the last index of the given element in the given sequence.
--
-- If the index is not no index, then get(sequence, index) returns the element
-- sought. (This is proven, below.)
--
-- If the index is not no index, there is no other occurrence of the element
-- at a larger, valid index in the sequence. (This is proven, below.)
function last_index_of(sequence : sequence_type; element : element_type) returns (index : index_type);
let
    index = if element <> no_element then
            _find_last(sequence, element)
        else
            no_index;

    assert (index <> no_index => (nonempty_sequence(sequence) and
                                  valid_index(sequence, index) and 
                                  (_access(sequence, index) = element)));
tel;


-- ------------------------------------------------------------------------- --
-- predicates

-- True if the sequence contains the given element.
function contains(sequence : sequence_type; element : element_type) returns (r : bool);
let
    r = (any_index_of(sequence, element) <> no_index);
tel;


-- True if the given element is the first element in the sequence.
function is_first(sequence : sequence_type; element : element_type) returns (r : bool);
let
    r = (first_index_of(sequence, element) = sequence.first_index);
tel;


-- True if the given element is the last element in the sequence.
function is_last(sequence : sequence_type; element : element_type) returns (r : bool);
let
    r = (first_index_of(sequence, element) = sequence.last_index);
tel;


-- True if the element appears exactly once in the sequence.
function is_unique(sequence : sequence_type; element : element_type) returns (r : bool);
let
    r = (first_index_of(sequence, element) = last_index_of(sequence, element)) and
        (first_index_of(sequence, element) <> no_index);
tel;


-- True if the first occurrence of element1 is prior to the first occurrence of
-- element2 in the sequence.
function before(sequence : sequence_type; element1, element2 : element_type) returns (r : bool);
var
    index1, index2 : index_type;
let
    index1 = first_index_of(sequence, element1);
    index2 = first_index_of(sequence, element2);

    r = if index1 <> no_index and index2 <> no_index and element1 <> element2 then
            index1 < index2
        else
            false;
tel;


-- True if the last occurrence of element1 is prior to the last occurrence of
-- element2 in the sequence.
function after(sequence : sequence_type; element1, element2 : element_type) returns (r : bool);
var
    index1, index2 : index_type;
let
    index1 = last_index_of(sequence, element1);
    index2 = last_index_of(sequence, element2);

    r = if index1 <> no_index and index2 <> no_index and element1 <> element2 then
            index1 > index2
        else
            false;
tel;


-- True if any occurrence of element1 is adjacent to any occurrence of element2
-- in the sequence.
--
-- Note: currently there are no consistency checks that use this predicate.
function adjacent(sequence : sequence_type; element1, element2 : element_type) returns (r : bool);
var
    index1, index2, indexs : index_type;
let
    index1 = any_index_of(sequence, element1);
    index2 = any_index_of(sequence, element2);
    indexs = any_index_of(sequence, _free_valid_element());

    r = if index1 <> no_index and index2 <> no_index and element1 <> element2 then
            not (
                (index1 <= indexs and indexs <= index2) or
                (index2 <= indexs and indexs <= index1)
            )
        else
            false;
tel;


-- ------------------------------------------------------------------------- --
-- Proofs
--
-- We prove properties over our theory of sequences to ensure the internal
-- consistency of the theory.

-- Driver for verification of consistency properties
--
-- Inputs are skolemized universally quantified variables. For some properties,
-- we use the _free_<type> functions to get an existentially quantified
-- instance - but since those are *functions*, we can only use them once per
-- property to get a distinct instance.
node consistency_checks_for_sequences(
    sequence       : sequence_type; 
    search_index   : index_type; 
    search_element : element_type
) returns (
    r : bool
);
const
    free_element : element_type;
let
    -- --------------------------------------------------------------------- --
    -- Consistency checks for get
    --
    -- Also tests the contains predicate

    check "successful get implies containment"
        (
            nonempty_sequence(sequence) and
            valid_index(sequence, search_index)
        ) => (
            contains(sequence, get(sequence, search_index))
        );

    check "unsuccessful get implies no containment"
        (
            nonempty_sequence(sequence) and
            get(sequence, search_index) = no_element
        ) => (
            not contains(sequence, get(sequence, search_index))
        );


    -- --------------------------------------------------------------------- --
    -- Consistency checks for any_index_of

    check "successful any_index_of implies get will return search element"
        (
            nonempty_sequence(sequence) and
            any_index_of(sequence, search_element) <> no_index
        ) => (
            get(sequence, any_index_of(sequence, search_element)) = search_element
        );

    check "unsuccessful any_index_of implies get will not return search element"
        (
            nonempty_sequence(sequence) and
            any_index_of(sequence, search_element) = no_index and
            search_element <> no_element
        ) => (
            get(sequence, any_index_of(sequence, search_element)) <> search_element
        );

    check "unsuccessful any_index_of implies get will return no element"
        (
            nonempty_sequence(sequence) and
            any_index_of(sequence, search_element) = no_index
        ) => (
            get(sequence, any_index_of(sequence, search_element)) = no_element
        );


    -- --------------------------------------------------------------------- --
    -- Consistency checks for first_index_of

    check "successful first_index_of implies get will return search element"
        (
            nonempty_sequence(sequence) and
            first_index_of(sequence, search_element) <> no_index
        ) => (
            get(sequence, first_index_of(sequence, search_element)) = search_element
        );

    check "unsuccessful first_index_of implies get will not return search element"
        (
            nonempty_sequence(sequence) and
            first_index_of(sequence, search_element) = no_index and
            search_element <> no_element
        ) => (
            get(sequence, first_index_of(sequence, search_element)) <> search_element
        );

    check "unsuccessful first_index_of implies get will return no element"
        (
            nonempty_sequence(sequence) and
            first_index_of(sequence, search_element) = no_index
        ) => (
            get(sequence, first_index_of(sequence, search_element)) = no_element
        );


    -- --------------------------------------------------------------------- --
    -- Consistency checks for last_index_of

    check "successful last_index_of implies get will return search element"
        (
            nonempty_sequence(sequence) and
            last_index_of(sequence, search_element) <> no_index
        ) => (
            get(sequence, last_index_of(sequence, search_element)) = search_element
        );

    check "unsuccessful last_index_of implies get will not return search element"
        (
            nonempty_sequence(sequence) and
            last_index_of(sequence, search_element) = no_index and
            search_element <> no_element
        ) => (
            get(sequence, last_index_of(sequence, search_element)) <> search_element
        );

    check "unsuccessful last_index_of implies get will return no element"
        (
            nonempty_sequence(sequence) and
            last_index_of(sequence, search_element) = no_index
        ) => (
            get(sequence, last_index_of(sequence, search_element)) = no_element
        );


    -- --------------------------------------------------------------------- --
    -- Consistency checks for predicates

    check "is_first implies not before"
        (
            nonempty_sequence(sequence) and
            free_element <> search_element and
            is_first(sequence, search_element)
        ) => (
            not before(sequence, free_element, search_element)
        );

    check "is_last implies not after"
        (
            nonempty_sequence(sequence) and
            free_element <> search_element and
            is_last(sequence, search_element)
        ) => (
            not after(sequence, free_element, search_element)
        );

    check "is_unique implies first_index_of = any_index_of"
        (
            nonempty_sequence(sequence) and
            is_unique(sequence, search_element)
        ) => (
            first_index_of(sequence, search_element) = any_index_of(sequence, search_element)
        );

    -- Note: this doesn't prove because we currently have no constraint that
    --       first_index_of(get(index)) is guaranteed to return index even 
    --       if is_unique(get(index)). This seems like it would be a bit of a
    --       tricky property to add, and of currently marginal value.
    --
    --       It's important to note also that first_index_of(get(index))
    --       *will not necessarily* return index if not is_unique(get(index)).
    -- check "before works"
    --     (
    --         nonempty_sequence(sequence) and
    --         valid_index(sequence, search_index) and
    --         valid_index(sequence, search_index + 1) and
    --         is_unique(sequence, get(sequence, search_index)) and
    --         is_unique(sequence, get(sequence, search_index + 1))
    --     ) => (
    --         before(sequence, get(sequence, search_index), get(sequence, search_index + 1))
    --     );
tel;
