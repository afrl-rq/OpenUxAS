-- waypoint-manager.lus

include "../common/types.lus"
include "../common/pltl.lus"
include "../common/bus.lus"


-- Retrieve the next waypoint from a route.
node next_waypoint(route : route_type) returns (waypoint : waypoint_type);
var
    index : index_type;
let
    index = no_index -> if route = pre(route) then
                            pre(index) + 1
                        else
                            route.first_index;

    waypoint = get(route, index);
tel;

-- This constant represents a skolemized universally quantified variable
-- that we use to link details of a message appearing in the past with details
-- of our output message.
const  wm_future_out_msg : message;


--
-- The Waypoint Manager Service
--
node waypoint_manager(
    -- The message currently received by the service
    in_msg : message;

    -- The ID to be used for ID generation
    in_id : id_type;
) returns (
    -- The message currently sent by the service
    out_msg : message;
);
-- (*@contract
--     -- This property is a nice sanity check over our output.
--     guarantee "L1. Restatement of P1.
--       The Waypoint Manager never sends 'no waypoint' as part of a Mission
--       Command.\n  "
--     (
--         out_msg.kind = mission_command
--     ) => (
--         out_msg.waypoint <> no_waypoint
--     );

--     -- Sanity check on the handling of output message ID and output ID.
--     guarantee "L3. Restatement of P3.
--       The Waypoint Manager correctly sets the ID of messages it sends and
--       correctly updates its output ID.\n  "
--     (
--         out_msg <> no_message
--     ) => (
--         out_msg.id = in_id + 1
--     );

--     -- This property, which is interesting in its own right, functions as a
--     -- lemma for proving our requirement.
--     guarantee "L4. Restatement of P4.
--       When the Waypoint Manager sends a Mission Command message, the referenced
--       Automation Response message was previously received.\n  "
--     (
--         out_msg.kind  = mission_command and
--         out_msg.ref   = wm_future_out_msg.id
--     ) => (
--         pre(O(in_msg = wm_future_out_msg))
--     );

--     guarantee "G1. Restatement of R1.
--       When the Waypoint Manager sends a Mission Command message, the waypoint
--       sent is contained in the route that belongs to the previously received
--       Automation Response message that is referenced in the Mission Command
--       message.\n  "
--     (
--         out_msg.kind  = mission_command and
--         out_msg.ref   = wm_future_out_msg.id
--     ) => (
--         pre(O(in_msg = wm_future_out_msg)) and
--         contains(wm_future_out_msg.route, out_msg.waypoint)
--     );

--     guarantee "G2. Possible responses.\n  "
--     (
--         out_msg.kind = mission_command or
--         out_msg      = no_message
--     );

--     guarantee "G3. Output Trigger.
--       The Waypoint Manager only sends Mission Command messages in response to
--       Automation Response messages.\n  "
--     (
--         out_msg.kind = mission_command
--     ) => (
--         pre(O(in_msg.kind = automation_response))
--     );

--     guarantee "IC.\n  "
--     (
--         O(out_msg = no_message)
--     );
-- *)
var
    -- ===================================================================== --
    -- Service state
    --
    -- The route from which this service will stream waypoints
    route : route_type;

    -- The ID of the message that provided the route above
    route_msg_id : id_type;

    -- The waypoint to send
    waypoint : waypoint_type;


    -- ===================================================================== --
    -- Convenience variables
    pre_route           : route_type;
    pre_route_msg_id    : id_type;

const
    future_pre_route : route_type;
    future_pre_route_msg_id : id_type;

let
    -- ===================================================================== --
    -- Bookkeeping

    -- Compute prior values of relevant state variables.
    --
    -- We group these here for convenience in setting their initial conditions.
    pre_route        = no_route -> pre(route);
    pre_route_msg_id = no_id    -> pre(route_msg_id);


    -- ===================================================================== --
    -- Service Behavior

    -- These expressions serve as high-level specifications of service
    -- behavior. Each is preceded by a natural-language description of the
    -- specification, set off in quotes for clarity.

    -- "If there is a stored route, the service shall get the next waypoint
    --  from the route."
    --
    -- Note that this happens "before" we determine if there is a new route.
    waypoint = if pre_route <> no_route then
                   next_waypoint(pre_route)
               else
                   no_waypoint;


    -- "If there is a next waypoint, the service shall send the next waypoint
    --  in a Mission Command message that references the ID of the Automation
    --  Response message that provided the stored route."
    --
    -- Note two things:
    --  1. this happens "before" we determine if there is a new route that we
    --     we should store and from which we should start streaming waypoints.
    --     So the service will wait one time step before responding to a new
    --     route.
    --
    --  2. we don't update the waypoint_in_msg_id state variable until "after"
    --     we have determined if there's a new route (so that we can use the ID
    --     of the message setting the route to reset the waypoint_in_msg_id).
    --     Thus we manually increment the previous waypoint_in_msg_id here in
    --     building the message.
    out_msg   = if waypoint <> no_waypoint then
                    message {
                        kind     = mission_command;
                        id       = in_id + 1;
                        ref      = pre_route_msg_id;
                        route    = no_route;
                        waypoint = waypoint;
                    }
                else
                    no_message;


    -- "If the service receives an Automation Response message, the service
    --  shall store the route from the Automation Response message. Otherwise,
    --  if there is no next waypoint, the service shall clear the stored
    --  route."
    route = if in_msg.kind = automation_response and
               nonempty_sequence(in_msg.route)
            then
                in_msg.route
            else if waypoint <> no_waypoint then
                pre_route
            else
                no_route;


    -- "If the service receives an Automation Response message, the service
    --  shall store the ID of the Automation Response message."
    route_msg_id =  if in_msg.kind = automation_response and
                       nonempty_sequence(in_msg.route)
                    then
                        in_msg.id
                    else
                        pre_route_msg_id;


    -- ===================================================================== --
    -- Properties of Interest

    check "G2. Possible responses.\n  "
    (
        out_msg.kind = mission_command or
        out_msg      = no_message
    );

    check "G3. Output Trigger.
      The Waypoint Manager only sends Mission Command messages in response to
      Automation Response messages.\n  "
    (
        out_msg.kind = mission_command
    ) => (
        O(in_msg.kind = automation_response)
    );

    check "IC.\n  "
    (
        O(out_msg = no_message)
    );


    check "L1.\n  "
    (
        out_msg.kind = mission_command
    ) => (
        out_msg.ref = pre_route_msg_id
    );

    check "L2.\n  "
    (
        route_msg_id = in_msg.id or
        route_msg_id = pre_route_msg_id
    );

    check "L3.\n  "
    (
        out_msg.kind = mission_command
    ) => (
        O(route_msg_id = in_msg.id)
    );

    check "L4.\n  "
    (
        out_msg.kind = mission_command and

        pre_route_msg_id = future_pre_route_msg_id
    ) => (
        O(in_msg.id = future_pre_route_msg_id)
    );

    check "L5.\n  "
    (
        out_msg.kind     = mission_command and

        pre_route_msg_id = future_pre_route_msg_id
    ) => (
        O(in_msg.kind = automation_response and
          in_msg.id   = future_pre_route_msg_id)
    );

    check "L6.\n  "
    (
        out_msg.kind = mission_command and
        out_msg      = wm_future_out_msg and

        pre_route_msg_id = future_pre_route_msg_id
    ) => (
        O(wm_future_out_msg.ref = future_pre_route_msg_id) and
        O(in_msg.id = future_pre_route_msg_id)
    );

    check "L7.\n  "
    (
        out_msg.kind = mission_command and
        out_msg      = wm_future_out_msg and

        pre_route_msg_id = future_pre_route_msg_id
    ) => (
        O(wm_future_out_msg.ref = future_pre_route_msg_id) and
        O(in_msg.kind = automation_response and
          in_msg.id   = future_pre_route_msg_id)
    );

    check "L8\n  "
    (
        O(wm_future_out_msg.ref = future_pre_route_msg_id) and
        O(future_pre_route_msg_id = in_msg.id)
    ) => (
        O(wm_future_out_msg.ref = in_msg.id)
    );

    check "L9.\n  "
    (
        O(wm_future_out_msg.ref = future_pre_route_msg_id) and
        O(in_msg.kind = automation_response and
          in_msg.id   = future_pre_route_msg_id)
    ) => (
        O(in_msg.kind = automation_response and
          in_msg.id   = wm_future_out_msg.ref)
    );

    check "L10.\n  "
    (
        out_msg.kind = mission_command and
        out_msg      = wm_future_out_msg and

        pre_route_msg_id = future_pre_route_msg_id
    ) => (
        O(in_msg.id = wm_future_out_msg.ref)
    );


    -- This property is a nice sanity check over our output.
    check "P1.
      The Waypoint Manager never sends 'no waypoint' as part of a Mission
      Command.\n  "
    (
        out_msg.kind = mission_command
    ) => (
        out_msg.waypoint <> no_waypoint
    );

    check "P1.A. Witness antecedent of P1."
    not (
        out_msg.kind = mission_command
    );


    -- This property is a nice sanity check on our stored route.
    check "P2.
      Route is no_route xor a (valid) nonempty route.\n  "
    (
        route = no_route xor nonempty_sequence(route)
    );


    -- Sanity check on the handling of output message ID and output ID.
    check "P3.
      The Waypoint Manager correctly sets the ID of messages it sends and
      correctly updates its output ID.\n  "
    (
        out_msg <> no_message
    ) => (
        out_msg.id = in_id + 1
    );

    check "P3.A. Witness antecedent of P3."
    not (
        out_msg.kind = mission_command
    );

    -- This property, which is interesting in its own right, functions as a
    -- lemma for proving our requirement.
    check "P4.
      When the Waypoint Manager sends a Mission Command message, the referenced
      Automation Response message was previously received.\n  "
    (
        out_msg.kind = mission_command and
        out_msg      = wm_future_out_msg and

        -- Needed to trigger the lemmas above
        pre_route_msg_id = future_pre_route_msg_id
    ) => (
        O(in_msg.kind = automation_response and
          in_msg.id   = wm_future_out_msg.ref)
    );

    -- check "P4.A. Witness antecedent of P4."
    -- not (
    --     out_msg.kind = mission_command and
    --     out_msg      = wm_future_out_msg
    -- );

    -- Since we send waypoints from the route *before* we update the route
    -- stored based on any new message, this checks pre_route rather than
    -- route.
    --
    -- This is an essential lemma for P7, which is in turn essential for R1.
    -- check "P5.
    --   When the Waypoint Manager sends a Mission Command message, the stored
    --   route is contained in the referenced Automation Response message.\n  "
    -- (
    --     out_msg.kind  = mission_command and
    --     out_msg.ref   = wm_future_out_msg.id
    -- ) => (
    --     pre_route     = wm_future_out_msg.route
    -- );
    -- (
    --     out_msg.kind  = mission_command and
    --     out_msg       = wm_future_out_msg and
    --     pre_route     = future_pre_route
    -- ) => (
    --     O(in_msg.kind  = automation_response and
    --       in_msg.id    = wm_future_out_msg.ref and
    --       in_msg.route = future_pre_route)
    -- );

    -- check "P5.A. Witness antecedent of P5."
    -- not (
    --     out_msg.kind  = mission_command and
    --     out_msg.ref   = wm_future_out_msg.id
    -- );

    -- Since we send waypoints from the route *before* we update the route
    -- stored based on any new message, the contains predicate checks against
    -- pre_route.
    check "P6.
      When the Waypoint Manager sends a Mission Command message, the waypoint
      sent is contained in the stored route.\n  "
    (
        out_msg.kind = mission_command
    ) => (
        contains(pre_route, out_msg.waypoint)
    );

    check "P6.A. Witness antecedent of P6."
    not (
        out_msg.kind  = mission_command
    );

    -- check "P7.
    --   When the Waypoint Manager sends a Mission Command mssage, the waypoint
    --   sent is contained in the referenced Automation Response message.\n  "
    -- (
    --     out_msg.kind  = mission_command and
    --     out_msg.ref   = wm_future_out_msg.id
    -- ) => (
    --     contains(wm_future_out_msg.route, out_msg.waypoint)
    -- );

    -- check "P7.A. Witness antecedent of P7."
    -- not (
    --     out_msg.kind  = mission_command and
    --     out_msg.ref   = wm_future_out_msg.id
    -- );

    -- ===================================================================== --
    -- Service Requirements

    -- The service requirement is simply the composition of P4 and P7.
    -- check "R1.
    --   When the Waypoint Manager sends a Mission Command message, the waypoint
    --   sent is contained in the route that belongs to the previously received
    --   Automation Response message that is referenced in the Mission Command
    --   message.\n  "
    -- (
    --     out_msg.kind = mission_command and
    --     out_msg      = wm_future_out_msg
    -- ) => (
    --     O(in_msg.kind = automation_response and
    --       in_msg.id   = wm_future_out_msg.ref and
    --       contains(in_msg.route, wm_future_out_msg.waypoint))
    -- );

    -- check "R1.A. Witness antecedent of R1."
    -- not (
    --     out_msg.kind = mission_command and
    --     out_msg      = wm_future_out_msg
    -- );
tel;
