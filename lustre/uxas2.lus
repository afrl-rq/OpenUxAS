-- uxas2.lus
--
-- Note: jkind doesn't support include/import, so this is a monolithic model
-- of OpenUxAS.

-- Initial work on a model that includes service specification and that
-- represents stubbed-out nodes with uninterpreted functions.

-- Represent the kind of message sent with an enum.
type message_kind = enum {
    -- An empty message.
    --
    -- Relevant fields:
    --  [none]
    none,

    -- Mission Command.
    --
    -- Relevant fields:
    --  id
    --  waypoint
    mission_command,

    -- Automation Response
    --
    -- Relevant fields:
    --  id
    --  route
    automation_response,

    -- Unique Automation Response
    --
    -- Relevant fields:
    --  id
    --  route
    unique_automation_response
};


-- Represent the ID of a message with an unconstrained integer.
type id_type = int;

const no_id : id_type = -1;


-- Represent a route with an integer. 
--
-- This should be viewed as the index or identifier or an opaque reference to a
-- route. We can thus reason about two routes being identical (through
-- referential equality) and we can pass routes to uninterpreted functions that
-- stub out behavior over routes.
type route_type = int;

const no_route : route_type = -1;


-- Represent a waypoint with an int
--
-- This also should be viewed as an opaque reference to a waypoint.
type waypoint_type = int;

const no_waypoint : waypoint_type = -1;


-- Represent a message.
--
-- A more realistic representation would use a discriminated record, but we
-- don't have support for that in Lustre.
type message = struct {
    -- The kind of message
    kind     : message_kind;

    -- The ID of this message
    id       : id_type;

    -- The ID of another message that is referenced by this message
    ref      : id_type;

    -- A route
    route    : route_type;

    -- A waypoint
    waypoint : waypoint_type
};


-- An empty message. This is interpreted as no message having been received.
const no_message : message = message { 
    kind     = none;
    id       = no_id;
    ref      = no_id;
    route    = no_route;
    waypoint = no_waypoint
};


-- PLTL once operator.
node once(in : bool) returns (out : bool);
let
	out = in or (false -> pre out);
tel;


-- This predicate is an uninterpreted function that represents checking to see
-- if a given route contains a given waypoint.
function contains(route : route_type; waypoint : waypoint_type) returns (r: bool);


-- This is a stub that represents deferred functionality for getting waypoints
-- (in order) from a route.
--
-- In the body of the node(s) that use this function, we will have to assert
-- that the result of next_waypoint satisfies contains for the same route
-- whenever the returned waypoint is not no_waypoint.
function next_waypoint(route : route_type; last_waypoint : waypoint_type) returns (waypoint : waypoint_type);
-- contract
--  waypoint <> no_waypoint = contains(route, waypoint);


--
-- The Waypoint Manager Service
--
node waypoint_manager(
    -- The message currently received by the service
    msg: message;
    
    -- These inputs represent skolemized universally quantified variables that
    -- we use to link details of a message appearing the past with details of
    -- our output message.
    automation_response_id    : id_type;
    automation_response_route : route_type
) returns (
    -- The message currently sent by the service
    out : message
);
var
    -- Service state
    --
    -- The route from which this service will stream waypoints
    route : route_type;

    -- The ID of the message that provided the route above
    route_msg_id : id_type;

    -- The waypoint to send
    waypoint : waypoint_type;

    -- The ID of the message that will send the waypoint
    waypoint_msg_id : id_type;


    -- Convenience variables
    pre_route           : route_type;
    pre_route_msg_id    : id_type;
    pre_waypoint        : waypoint_type;
    pre_waypoint_msg_id : id_type;

    -- Property variables (ghost code)
    post : bool;
    waypoint_on_route : bool;
    route_in_referenced_prior_message : bool;
    dont_send_no_waypoint : bool;
let
    -- ===================================================================== --
    -- Bookkeeping

    -- Constrain the skolemized inputs to be freely chosen constants.
    assert (automation_response_id    = pre(automation_response_id));
    assert (automation_response_route = pre(automation_response_route));

    -- Compute prior values of relevant state variables.
    --
    -- We group these here for convenience in setting their initial conditions.
    pre_route           = no_route    -> pre(route);
    pre_route_msg_id    = no_id       -> pre(route_msg_id);
    pre_waypoint        = no_waypoint -> pre(waypoint);
    pre_waypoint_msg_id = no_id       -> pre(waypoint_msg_id);


    -- ===================================================================== --
    -- Service Behavior

    -- These expressions serve as high-level specifications of service
    -- behavior. Each is preceded by a natural-language description of the
    -- specification, set off in quotes for clarity.

    -- "If there is a stored route, the service shall get the next waypoint
    --  from the route."
    --
    -- Note that this happens "before" we determine if there is a new route.
    waypoint = if pre_route <> no_route then
                   next_waypoint(pre_route, pre_waypoint)
               else
                   no_waypoint;

    -- Assert the contract of next_waypoint (since we can't otherwise
    -- constrain the uninterpreted function).
    assert ((waypoint <> no_waypoint) = contains(pre_route, waypoint));


    -- "If there is a next waypoint, the service shall send the next waypoint
    --  in a Mission Command message that references the ID of the Automation
    --  Response message that provided the stored route."
    --
    -- Note two things:
    --  1. this happens "before" we determine if there is a new route that we
    --     we should store and from which we should start streaming waypoints.
    --     So the service will wait one time step before responding to a new
    --     route.
    --
    --  2. we don't update the waypoint_msg_id state variable until "after" we
    --     have determined if there's a new route (so that we can use the ID
    --     of the message setting the route to reset the waypoint_msg_id). Thus
    --     we manually increment the previous waypoint_msg_id here in building
    --     the message.
    out   = if waypoint <> no_waypoint then
                message {
                    kind     = mission_command;
                    id       = pre_waypoint_msg_id + 1;
                    ref      = pre_route_msg_id;
                    route    = no_route;
                    waypoint = waypoint
                }
            else
                no_message;


    -- "If the service receives an Automation Response message, the service
    --  shall store the route from the Automation Response message. Otherwise,
    --  if there is no next waypoint, the service shall clear the stored
    --  route."
    route = if msg.kind = automation_response then
                msg.route
            else if waypoint <> no_waypoint then
                pre_route
            else
                no_route;


    -- "If the service receives an Automation Response message, the service
    --  shall store the ID of the Automation Response message."
    route_msg_id = if msg.kind = automation_response then
                       msg.id
                   else
                       pre_route_msg_id;


    -- "The service shall generate an ID for the Mission Command message."
    waypoint_msg_id = if msg.kind = automation_response then
                          msg.id + 1
                      else if waypoint <> no_waypoint then
                          pre_waypoint_msg_id + 1
                      else
                          no_id;


    -- ===================================================================== --
    -- Properties of Interest
    
    -- The service never sends "no waypoint" as part of a Mission Command.
    dont_send_no_waypoint = (
        out.kind = mission_command
    ) => (
        out.waypoint <> no_waypoint
    );
    --%PROPERTY dont_send_no_waypoint;
    
    -- Here, we use these properties to build up to the service postcondition,
    -- because it's easier to think about the property decomposed.

    -- "When the Waypoint Manager sends a Mission Command, the waypoint sent is
    --  contained in the stored route."
    --
    -- Since we send waypoints from the route *before* we update the route
    -- stored based on any new message, the contains predicate checks against
    -- pre_route.
    waypoint_on_route = (
        out.kind = mission_command
    ) => (
        contains(pre_route, out.waypoint)
    );
    -- (disabled separate check)
    -- %PROPERTY waypoint_on_route;

    -- "When the Waypoint Manager sends a Mission Command, the stored route
    --  belongs to the previously received Automation Response that is
    --  referenced in the Mission Command."
    --
    -- Again, the check in the antecedent here uses pre_route, because we send
    -- Mission Commands prior to updating the stored route.
    route_in_referenced_prior_message = (
        out.kind  = mission_command and
        out.ref   = automation_response_id and
        pre_route = automation_response_route
    ) => (
        once(msg.kind  = automation_response and 
             msg.id    = automation_response_id and 
             msg.route = automation_response_route)
    );
    -- (disabled separate check)
    -- %PROPERTY route_in_referenced_prior_message;


    -- ===================================================================== --
    -- Service Requirements

    -- "When the Waypoint Manager sends a Mission Command, the waypoint sent is
    --  contained in the route that belongs to the previously received
    --  Automation Response that is referenced in the Mission Command."
    post = waypoint_on_route and route_in_referenced_prior_message;
    --%PROPERTY post;
tel;
